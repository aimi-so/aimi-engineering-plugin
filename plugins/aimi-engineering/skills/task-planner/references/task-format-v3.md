# tasks.json Format Reference — Schema v3

## Overview

Schema v3 replaces the boolean `passes` field with a richer `status` enum and adds explicit `dependsOn` for inter-story dependency tracking. This enables parallel execution of independent stories and clearer lifecycle management.

**Filename:** `.aimi/tasks/YYYY-MM-DD-[feature-name]-tasks.json`

Example: `.aimi/tasks/2026-02-27-dep-graph-tasks.json`

---

## Schema

```json
{
  "schemaVersion": "3.0",
  "metadata": {
    "title": "string",
    "type": "feat|ref|bug|chore",
    "branchName": "string",
    "createdAt": "YYYY-MM-DD",
    "planPath": "string | null (optional)",
    "brainstormPath": "string (optional)",
    "maxConcurrency": 4
  },
  "userStories": [Story]
}
```

---

## Field Definitions

### Root Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `schemaVersion` | string | Yes | Must be `"3.0"` |
| `metadata` | object | Yes | Project metadata |
| `userStories` | array | Yes | Array of Story objects |

### Metadata Fields

| Field | Type | Required | Default | Description |
|-------|------|----------|---------|-------------|
| `title` | string | Yes | — | Plan title (e.g., `"feat: Add user authentication"`) |
| `type` | string | Yes | — | One of: `feat`, `ref`, `bug`, `chore` |
| `branchName` | string | Yes | — | Git branch name (e.g., `"feat/add-user-auth"`) |
| `createdAt` | string | Yes | — | Creation date (`YYYY-MM-DD`) |
| `planPath` | string \| null | No | `null` | Path to source plan markdown file. `null` when generated by task-planner. |
| `brainstormPath` | string | No | — | Path to brainstorm document if one was used as context. |
| `maxConcurrency` | number | No | `4` | Maximum number of stories that can execute in parallel. Applies only to stories whose dependencies are all satisfied. |

### Story Fields

Each story is ONE atomic unit of work completable in a single agent iteration.

| Field | Type | Required | Default | Description |
|-------|------|----------|---------|-------------|
| `id` | string | Yes | — | Unique identifier (e.g., `US-001`, `US-002`) |
| `title` | string | Yes | — | Short story title (max 200 chars) |
| `description` | string | Yes | — | User story format: "As a [user], I want [feature] so that [benefit]" (max 500 chars) |
| `acceptanceCriteria` | string[] | Yes | — | Verifiable criteria (must include `"Typecheck passes"`, each max 300 chars) |
| `priority` | number | Yes | — | Tiebreaker for stories at the same dependency depth. Lower = runs first among peers. |
| `status` | string | Yes | `"pending"` | One of: `"pending"`, `"in_progress"`, `"completed"`, `"failed"`, `"skipped"` |
| `dependsOn` | string[] | Yes | `[]` | Array of story IDs this story depends on (e.g., `["US-001", "US-002"]`) |
| `notes` | string | No | `""` | Error details, learnings, or skip reason |

---

## Status State Machine

Stories follow a strict state machine. Only the transitions listed below are valid.

```
                ┌────────────┐
                │   pending   │
                └──────┬─────┘
                       │
            ┌──────────┼──────────┐
            │          │          │
            ▼          │          ▼
     ┌─────────────┐   │   ┌──────────┐
     │ in_progress  │   │   │  skipped  │
     └──────┬──────┘   │   └──────────┘
            │          │
      ┌─────┴─────┐   │
      │           │   │
      ▼           ▼   │
┌───────────┐ ┌────────┐
│ completed  │ │ failed  │
└───────────┘ └───┬────┘
                  │
                  │ (retry)
                  ▼
           ┌─────────────┐
           │ in_progress  │
           └─────────────┘
```

### Valid Transitions

| From | To | Trigger |
|------|----|---------|
| `pending` | `in_progress` | Agent picks up story for execution |
| `pending` | `skipped` | User decides to skip story |
| `in_progress` | `completed` | All acceptance criteria pass |
| `in_progress` | `failed` | Execution error or criteria not met |
| `failed` | `in_progress` | Retry attempt (manual or automatic) |

### Invalid Transitions

These transitions are NOT allowed:

- `completed` to any state (completed is terminal)
- `skipped` to any state (skipped is terminal; to un-skip, set back to `pending` manually)
- `pending` to `completed` (must go through `in_progress`)
- `pending` to `failed` (must go through `in_progress`)

### Status Definitions

| Status | Meaning |
|--------|---------|
| `pending` | Not started. Waiting for dependencies or turn in queue. |
| `in_progress` | Currently being executed by an agent. |
| `completed` | All acceptance criteria verified. Terminal state. |
| `failed` | Execution attempted but did not meet criteria. Can be retried. |
| `skipped` | Deliberately excluded by the user. Terminal state. |

---

## Dependency System (`dependsOn`)

### How It Works

Each story declares which other stories must complete before it can start. The `dependsOn` field is an array of story IDs.

A story is **ready to execute** when:
1. Its `status` is `pending`
2. Every story ID in its `dependsOn` array has `status` equal to `completed` OR `skipped`

### Priority as Tiebreaker

When multiple stories are ready simultaneously (all dependencies satisfied), `priority` determines the execution order among them. Lower priority values execute first. This means:

- `dependsOn` determines **what can run** (structural ordering)
- `priority` determines **what runs first** among equally-ready stories (tiebreaker)

### Validation Rules

Before processing a tasks.json file, validate the dependency graph:

| Rule | Check | Error |
|------|-------|-------|
| No self-references | No story lists its own ID in `dependsOn` | `Error: Story [ID] depends on itself.` |
| All references exist | Every ID in `dependsOn` must match an existing story ID | `Error: Story [ID] depends on [REF] which does not exist.` |
| No circular dependencies | The dependency graph must be a DAG (directed acyclic graph) | `Error: Circular dependency detected: [ID] -> ... -> [ID].` |
| Valid ID format | All IDs in `dependsOn` match `US-\d{3}` pattern | `Error: Story [ID] has invalid dependsOn reference [REF].` |

### Circular Dependency Detection

Use topological sort (Kahn's algorithm) to detect cycles:

1. Build adjacency list from `dependsOn` fields
2. Compute in-degree for each story
3. Start with all stories that have in-degree 0
4. Process queue: for each story, reduce in-degree of dependents
5. If any stories remain unprocessed after queue is empty, a cycle exists

### Examples

**Linear chain:**
```json
{ "id": "US-001", "dependsOn": [] }
{ "id": "US-002", "dependsOn": ["US-001"] }
{ "id": "US-003", "dependsOn": ["US-002"] }
```
Execution: US-001, then US-002, then US-003.

**Diamond pattern (parallel middle layer):**
```json
{ "id": "US-001", "dependsOn": [], "priority": 1 }
{ "id": "US-002", "dependsOn": ["US-001"], "priority": 2 }
{ "id": "US-003", "dependsOn": ["US-001"], "priority": 3 }
{ "id": "US-004", "dependsOn": ["US-002", "US-003"], "priority": 4 }
```
Execution: US-001 first; then US-002 and US-003 can run in parallel; US-004 runs after both complete.

**Independent roots (parallel start):**
```json
{ "id": "US-001", "dependsOn": [], "priority": 1 }
{ "id": "US-002", "dependsOn": [], "priority": 2 }
{ "id": "US-003", "dependsOn": ["US-001", "US-002"], "priority": 3 }
```
Execution: US-001 and US-002 can run in parallel; US-003 runs after both complete.

---

## `maxConcurrency`

Controls how many stories execute in parallel when their dependencies are satisfied.

| Value | Behavior |
|-------|----------|
| `1` | Sequential execution (same as v2.2 behavior) |
| `4` (default) | Up to 4 stories run in parallel |
| `0` or omitted | Uses default (`4`) |

The executor picks up to `maxConcurrency` ready stories, ordered by `priority`, and runs them simultaneously.

---

## Complete Example

```json
{
  "schemaVersion": "3.0",
  "metadata": {
    "title": "feat: Add task status feature",
    "type": "feat",
    "branchName": "feat/add-task-status",
    "createdAt": "2026-02-27",
    "planPath": null,
    "maxConcurrency": 2
  },
  "userStories": [
    {
      "id": "US-001",
      "title": "Add status field to tasks table",
      "description": "As a developer, I need to store task status in the database.",
      "acceptanceCriteria": [
        "Add status column: 'pending' | 'in_progress' | 'done' (default 'pending')",
        "Generate and run migration successfully",
        "Typecheck passes"
      ],
      "priority": 1,
      "status": "pending",
      "dependsOn": [],
      "notes": ""
    },
    {
      "id": "US-002",
      "title": "Display status badge on task cards",
      "description": "As a user, I want to see task status at a glance.",
      "acceptanceCriteria": [
        "Each task card shows colored status badge",
        "Badge colors: gray=pending, blue=in_progress, green=done",
        "Typecheck passes",
        "Verify in browser"
      ],
      "priority": 2,
      "status": "pending",
      "dependsOn": ["US-001"],
      "notes": ""
    },
    {
      "id": "US-003",
      "title": "Add status toggle to task list rows",
      "description": "As a user, I want to change task status directly from the list.",
      "acceptanceCriteria": [
        "Each row has status dropdown or toggle",
        "Changing status saves immediately",
        "UI updates without page refresh",
        "Typecheck passes",
        "Verify in browser"
      ],
      "priority": 3,
      "status": "pending",
      "dependsOn": ["US-001"],
      "notes": ""
    },
    {
      "id": "US-004",
      "title": "Filter tasks by status",
      "description": "As a user, I want to filter the list to see only certain statuses.",
      "acceptanceCriteria": [
        "Filter dropdown: All | Pending | In Progress | Done",
        "Filter persists in URL params",
        "Typecheck passes",
        "Verify in browser"
      ],
      "priority": 4,
      "status": "pending",
      "dependsOn": ["US-002", "US-003"],
      "notes": ""
    }
  ]
}
```

In this example, US-002 and US-003 can run in parallel (both depend only on US-001), capped at `maxConcurrency: 2`. US-004 waits for both to complete.

---

## Backward Compatibility (v2.2 Detection and Fallback)

### Detection

Check the `schemaVersion` field to determine which schema to apply:

| `schemaVersion` | Schema |
|-----------------|--------|
| `"3.0"` | v3 — use `status`, `dependsOn`, `maxConcurrency` |
| `"2.2"` or `"2.1"` | v2.x — use `passes`, `skipped`, priority-only ordering |

### Fallback Behavior

When a consumer encounters a v2.2 file:

1. **Treat `passes: true` as `status: "completed"`**
2. **Treat `passes: false` + `skipped: true` as `status: "skipped"`**
3. **Treat `passes: false` + (no `skipped` or `skipped: false`) as `status: "pending"`**
4. **Infer `dependsOn` from priority**: Each story depends on all stories with lower priority values (sequential chain)
5. **Use `maxConcurrency: 1`** (v2.2 was always sequential)

This means existing tooling (CLI, execute command) can operate on v2.2 files by applying this mapping at load time. No file modification needed.

### Runtime Detection Example

```
function detectSchema(tasksJson):
  if tasksJson.schemaVersion == "3.0":
    return "v3"
  if tasksJson.schemaVersion in ["2.2", "2.1"]:
    return "v2"
  error("Unknown schema version: " + tasksJson.schemaVersion)
```

---

## Migration: v2.2 to v3

### Automatic Conversion Rules

| v2.2 Field | v3 Equivalent | Conversion |
|------------|---------------|------------|
| `passes: true` | `status: "completed"` | Direct mapping |
| `passes: false` + `skipped: true` | `status: "skipped"` | Combine two fields |
| `passes: false` (no skip) | `status: "pending"` | Default to pending |
| `schemaVersion: "2.2"` | `schemaVersion: "3.0"` | Bump version |
| (not present) | `maxConcurrency: 4` | Add with default |
| (not present) | `dependsOn` | Infer from priority layers |

### Inferring `dependsOn` from Priority

v2.2 used `priority` as the sole ordering mechanism. To convert to v3 dependencies:

1. **Group stories by priority value** (same priority = same layer)
2. **Each story depends on ALL stories in the previous layer**
3. **Stories within the same layer have no dependencies on each other** (they were conceptually independent)

**Example:**

v2.2 priorities: `US-001(1), US-002(2), US-003(2), US-004(3)`

Converted `dependsOn`:
- `US-001`: `[]` (layer 1, no prior layer)
- `US-002`: `["US-001"]` (layer 2 depends on layer 1)
- `US-003`: `["US-001"]` (layer 2 depends on layer 1)
- `US-004`: `["US-002", "US-003"]` (layer 3 depends on layer 2)

### Fields Removed in v3

| Field | Replacement |
|-------|-------------|
| `passes` (boolean) | `status` (string enum) |
| `skipped` (boolean) | `status: "skipped"` |

### Migration Steps

1. Read the v2.2 tasks.json file
2. For each story:
   a. Map `passes`/`skipped` to `status` per the table above
   b. Remove `passes` and `skipped` fields
   c. Add `dependsOn` by grouping stories into priority layers
3. Add `maxConcurrency: 4` to metadata (or `1` if sequential execution is preferred)
4. Set `schemaVersion` to `"3.0"`
5. Write the updated file

### Migration Validation

After migration, run the full v3 validation:
- All `dependsOn` references must exist
- No circular dependencies
- No self-references
- All required fields present
- Status values are valid enum members

---

## Validation Rules

### Required Fields Check

Before processing, validate:

1. `schemaVersion` must be `"3.0"`
2. `metadata.title` must be non-empty
3. `metadata.type` must be one of: `feat`, `ref`, `bug`, `chore`
4. `metadata.branchName` must be non-empty and match `^[a-zA-Z0-9][a-zA-Z0-9/_-]*$`
5. `metadata.maxConcurrency` (if present) must be a positive integer
6. `userStories` must have at least one item
7. Each story must have: `id`, `title`, `description`, `acceptanceCriteria`, `priority`, `status`, `dependsOn`
8. Each story's `status` must be one of: `pending`, `in_progress`, `completed`, `failed`, `skipped`
9. Each story's `dependsOn` must be a string array
10. Each story's `acceptanceCriteria` must include `"Typecheck passes"`
11. No duplicate story IDs
12. No duplicate priority values
13. Dependency graph must be a valid DAG (no cycles, no self-refs, all refs exist)

### Validation Error Format

```
Error: Invalid tasks.json - [field] is missing or invalid.
Fix: [specific action to fix]
```

Examples:
```
Error: Invalid tasks.json - US-003.dependsOn references "US-099" which does not exist.
Fix: Remove "US-099" from US-003.dependsOn or add a story with id "US-099".

Error: Invalid tasks.json - Circular dependency detected: US-001 -> US-002 -> US-001.
Fix: Remove one of the dependency edges to break the cycle.

Error: Invalid tasks.json - US-002.status is "done" which is not a valid status.
Fix: Use one of: pending, in_progress, completed, failed, skipped.
```

---

## Story Sizing (Unchanged from v2.2)

**Each story must be completable in ONE agent iteration (one context window).**

See `story-decomposition.md` for full sizing and ordering rules.

---

## Story ID Convention (Unchanged from v2.2)

Story IDs follow the pattern: `US-XXX`

- `US-001`: First story
- `US-002`: Second story
- `US-010`: Tenth story

---

## Changes from v2.2 Summary

| Aspect | v2.2 | v3 |
|--------|------|----|
| Completion tracking | `passes: boolean` + `skipped: boolean` | `status` enum (5 states) |
| Dependency ordering | `priority` only (implicit sequential) | `dependsOn` (explicit DAG) + `priority` as tiebreaker |
| Parallel execution | Not supported | Supported via `dependsOn` + `maxConcurrency` |
| Retry visibility | Re-run same story | `failed` -> `in_progress` transition |
| In-progress tracking | Not tracked | `in_progress` status |
| Schema version | `"2.2"` | `"3.0"` |
