# tasks.json Format Reference — Schema v3

## Overview

Schema v3 uses a `status` enum for lifecycle tracking and explicit `dependsOn` arrays for inter-story dependency graphs. This enables parallel execution of independent stories and clearer lifecycle management.

**Filename:** `.aimi/tasks/YYYY-MM-DD-[feature-name]-tasks.json`

Example: `.aimi/tasks/2026-02-27-dep-graph-tasks.json`

---

## Schema

```json
{
  "schemaVersion": "3.0",
  "metadata": {
    "title": "string",
    "type": "feat|ref|bug|chore",
    "branchName": "string",
    "createdAt": "YYYY-MM-DD",
    "planPath": "string | null (optional)",
    "brainstormPath": "string (optional)",
    "maxConcurrency": 4
  },
  "userStories": [Story]
}
```

---

## Field Definitions

### Root Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `schemaVersion` | string | Yes | Must be `"3.0"` |
| `metadata` | object | Yes | Project metadata |
| `userStories` | array | Yes | Array of Story objects |

### Metadata Fields

| Field | Type | Required | Default | Description |
|-------|------|----------|---------|-------------|
| `title` | string | Yes | — | Plan title (e.g., `"feat: Add user authentication"`) |
| `type` | string | Yes | — | One of: `feat`, `ref`, `bug`, `chore` |
| `branchName` | string | Yes | — | Git branch name (e.g., `"feat/add-user-auth"`) |
| `createdAt` | string | Yes | — | Creation date (`YYYY-MM-DD`) |
| `planPath` | string \| null | No | `null` | Path to source plan markdown file. `null` when generated by task-planner. |
| `brainstormPath` | string | No | — | Path to brainstorm document if one was used as context. |
| `maxConcurrency` | number | No | `4` | Maximum number of stories that can execute in parallel. Applies only to stories whose dependencies are all satisfied. |

### Story Fields

Each story is ONE atomic unit of work completable in a single agent iteration.

| Field | Type | Required | Default | Description |
|-------|------|----------|---------|-------------|
| `id` | string | Yes | — | Unique identifier (e.g., `US-001`, `US-002`) |
| `title` | string | Yes | — | Short story title (max 200 chars) |
| `description` | string | Yes | — | User story format: "As a [user], I want [feature] so that [benefit]" (max 500 chars) |
| `acceptanceCriteria` | string[] | Yes | — | Verifiable criteria (must include `"Typecheck passes"`, each max 300 chars) |
| `priority` | number | Yes | — | Tiebreaker for stories at the same dependency depth. Lower = runs first among peers. |
| `status` | string | Yes | `"pending"` | One of: `"pending"`, `"in_progress"`, `"completed"`, `"failed"`, `"skipped"` |
| `dependsOn` | string[] | Yes | `[]` | Array of story IDs this story depends on (e.g., `["US-001", "US-002"]`) |
| `notes` | string | No | `""` | Error details, learnings, or skip reason |

---

## Status State Machine

Stories follow a strict state machine. Only the transitions listed below are valid.

```
                ┌────────────┐
                │   pending   │
                └──────┬─────┘
                       │
            ┌──────────┼──────────┐
            │          │          │
            ▼          │          ▼
     ┌─────────────┐   │   ┌──────────┐
     │ in_progress  │   │   │  skipped  │
     └──────┬──────┘   │   └──────────┘
            │          │
      ┌─────┴─────┐   │
      │           │   │
      ▼           ▼   │
┌───────────┐ ┌────────┐
│ completed  │ │ failed  │
└───────────┘ └───┬────┘
                  │
                  │ (retry)
                  ▼
           ┌─────────────┐
           │ in_progress  │
           └─────────────┘
```

### Valid Transitions

| From | To | Trigger |
|------|----|---------|
| `pending` | `in_progress` | Agent picks up story for execution |
| `pending` | `skipped` | User decides to skip story |
| `in_progress` | `completed` | All acceptance criteria pass |
| `in_progress` | `failed` | Execution error or criteria not met |
| `failed` | `in_progress` | Retry attempt (manual or automatic) |

### Invalid Transitions

These transitions are NOT allowed:

- `completed` to any state (completed is terminal)
- `skipped` to any state (skipped is terminal; to un-skip, set back to `pending` manually)
- `pending` to `completed` (must go through `in_progress`)
- `pending` to `failed` (must go through `in_progress`)

### Status Definitions

| Status | Meaning |
|--------|---------|
| `pending` | Not started. Waiting for dependencies or turn in queue. |
| `in_progress` | Currently being executed by an agent. |
| `completed` | All acceptance criteria verified. Terminal state. |
| `failed` | Execution attempted but did not meet criteria. Can be retried. |
| `skipped` | Deliberately excluded by the user. Terminal state. |

---

## Dependency System (`dependsOn`)

### How It Works

Each story declares which other stories must complete before it can start. The `dependsOn` field is an array of story IDs.

A story is **ready to execute** when:
1. Its `status` is `pending`
2. Every story ID in its `dependsOn` array has `status` equal to `completed` OR `skipped`

### Priority as Tiebreaker

When multiple stories are ready simultaneously (all dependencies satisfied), `priority` determines the execution order among them. Lower priority values execute first. This means:

- `dependsOn` determines **what can run** (structural ordering)
- `priority` determines **what runs first** among equally-ready stories (tiebreaker)

### Validation Rules

Before processing a tasks.json file, validate the dependency graph:

| Rule | Check | Error |
|------|-------|-------|
| No self-references | No story lists its own ID in `dependsOn` | `Error: Story [ID] depends on itself.` |
| All references exist | Every ID in `dependsOn` must match an existing story ID | `Error: Story [ID] depends on [REF] which does not exist.` |
| No circular dependencies | The dependency graph must be a DAG (directed acyclic graph) | `Error: Circular dependency detected: [ID] -> ... -> [ID].` |
| Valid ID format | All IDs in `dependsOn` match `US-\d{3}` pattern | `Error: Story [ID] has invalid dependsOn reference [REF].` |

### Circular Dependency Detection

Use topological sort (Kahn's algorithm) to detect cycles:

1. Build adjacency list from `dependsOn` fields
2. Compute in-degree for each story
3. Start with all stories that have in-degree 0
4. Process queue: for each story, reduce in-degree of dependents
5. If any stories remain unprocessed after queue is empty, a cycle exists

### Examples

**Linear chain:**
```json
{ "id": "US-001", "dependsOn": [] }
{ "id": "US-002", "dependsOn": ["US-001"] }
{ "id": "US-003", "dependsOn": ["US-002"] }
```
Execution: US-001, then US-002, then US-003.

**Diamond pattern (parallel middle layer):**
```json
{ "id": "US-001", "dependsOn": [], "priority": 1 }
{ "id": "US-002", "dependsOn": ["US-001"], "priority": 2 }
{ "id": "US-003", "dependsOn": ["US-001"], "priority": 3 }
{ "id": "US-004", "dependsOn": ["US-002", "US-003"], "priority": 4 }
```
Execution: US-001 first; then US-002 and US-003 can run in parallel; US-004 runs after both complete.

**Independent roots (parallel start):**
```json
{ "id": "US-001", "dependsOn": [], "priority": 1 }
{ "id": "US-002", "dependsOn": [], "priority": 2 }
{ "id": "US-003", "dependsOn": ["US-001", "US-002"], "priority": 3 }
```
Execution: US-001 and US-002 can run in parallel; US-003 runs after both complete.

---

## `maxConcurrency`

Controls how many stories execute in parallel when their dependencies are satisfied.

| Value | Behavior |
|-------|----------|
| `1` | Sequential execution (one story at a time) |
| `4` (default) | Up to 4 stories run in parallel |
| `0` or omitted | Uses default (`4`) |

The executor picks up to `maxConcurrency` ready stories, ordered by `priority`, and runs them simultaneously.

---

## Complete Example

```json
{
  "schemaVersion": "3.0",
  "metadata": {
    "title": "feat: Add task status feature",
    "type": "feat",
    "branchName": "feat/add-task-status",
    "createdAt": "2026-02-27",
    "planPath": null,
    "maxConcurrency": 2
  },
  "userStories": [
    {
      "id": "US-001",
      "title": "Add status field to tasks table",
      "description": "As a developer, I need to store task status in the database.",
      "acceptanceCriteria": [
        "Add status column: 'pending' | 'in_progress' | 'done' (default 'pending')",
        "Generate and run migration successfully",
        "Typecheck passes"
      ],
      "priority": 1,
      "status": "pending",
      "dependsOn": [],
      "notes": ""
    },
    {
      "id": "US-002",
      "title": "Display status badge on task cards",
      "description": "As a user, I want to see task status at a glance.",
      "acceptanceCriteria": [
        "Each task card shows colored status badge",
        "Badge colors: gray=pending, blue=in_progress, green=done",
        "Typecheck passes",
        "Verify in browser"
      ],
      "priority": 2,
      "status": "pending",
      "dependsOn": ["US-001"],
      "notes": ""
    },
    {
      "id": "US-003",
      "title": "Add status toggle to task list rows",
      "description": "As a user, I want to change task status directly from the list.",
      "acceptanceCriteria": [
        "Each row has status dropdown or toggle",
        "Changing status saves immediately",
        "UI updates without page refresh",
        "Typecheck passes",
        "Verify in browser"
      ],
      "priority": 3,
      "status": "pending",
      "dependsOn": ["US-001"],
      "notes": ""
    },
    {
      "id": "US-004",
      "title": "Filter tasks by status",
      "description": "As a user, I want to filter the list to see only certain statuses.",
      "acceptanceCriteria": [
        "Filter dropdown: All | Pending | In Progress | Done",
        "Filter persists in URL params",
        "Typecheck passes",
        "Verify in browser"
      ],
      "priority": 4,
      "status": "pending",
      "dependsOn": ["US-002", "US-003"],
      "notes": ""
    }
  ]
}
```

In this example, US-002 and US-003 can run in parallel (both depend only on US-001), capped at `maxConcurrency: 2`. US-004 waits for both to complete.

---

## Validation Rules

### Required Fields Check

Before processing, validate:

1. `schemaVersion` must be `"3.0"`
2. `metadata.title` must be non-empty
3. `metadata.type` must be one of: `feat`, `ref`, `bug`, `chore`
4. `metadata.branchName` must be non-empty and match `^[a-zA-Z0-9][a-zA-Z0-9/_-]*$`
5. `metadata.maxConcurrency` (if present) must be a positive integer
6. `userStories` must have at least one item
7. Each story must have: `id`, `title`, `description`, `acceptanceCriteria`, `priority`, `status`, `dependsOn`
8. Each story's `status` must be one of: `pending`, `in_progress`, `completed`, `failed`, `skipped`
9. Each story's `dependsOn` must be a string array
10. Each story's `acceptanceCriteria` must include `"Typecheck passes"`
11. No duplicate story IDs
12. No duplicate priority values
13. Dependency graph must be a valid DAG (no cycles, no self-refs, all refs exist)

### Validation Error Format

```
Error: Invalid tasks.json - [field] is missing or invalid.
Fix: [specific action to fix]
```

Examples:
```
Error: Invalid tasks.json - US-003.dependsOn references "US-099" which does not exist.
Fix: Remove "US-099" from US-003.dependsOn or add a story with id "US-099".

Error: Invalid tasks.json - Circular dependency detected: US-001 -> US-002 -> US-001.
Fix: Remove one of the dependency edges to break the cycle.

Error: Invalid tasks.json - US-002.status is "done" which is not a valid status.
Fix: Use one of: pending, in_progress, completed, failed, skipped.
```

---

## Story Sizing

**Each story must be completable in ONE agent iteration (one context window).**

See `story-decomposition.md` for full sizing and ordering rules.

---

## Story ID Convention

Story IDs follow the pattern: `US-XXX`

- `US-001`: First story
- `US-002`: Second story
- `US-010`: Tenth story

